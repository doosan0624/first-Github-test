스프링 개념 정리글  (스프링 핵심 원리 끝나고 다시 재정리 하기)
  * **Spring MVC란**
    + Spring 프레임워크에서 제공하는 웹 모듈
    + MVC는 Model-View-Controller의 약자이고, 기본 시스템 모듈을 MVC로 나누어 구현되어 있다.
      1. Model은 '데이터' 디자인을 담당
         + ex) 상품 목록, 주문 내역 등  
      
      2. View는 '실제로 렌더링되어 보이는 페이지'를 담당
         + ex) .JSP 파일들이 여기에 해당된다.
      
      3. Controller는 사용자의 요청을 받고, 응답을 주는 '로직'을 담당
         + ex) GET 등의 uri 매핑이 해당

      
      4. Spring MVC 모듈을 사용하여, 백엔드 프로그래밍의 기본 프레임워크를 잡는다. 
        + Web 서버에 특화되어 만들어진 모듈, 개발자가 해야할 영역을 더 **적게** 만들어준다.
        + 즉, 기존에 Spring보다 더 깔끔하고 간편하게 개발 가능.

 * **빈(Bean)** 
  1. Spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라는 용어로 부른다.
  2. new 연산자로 어떤 객체를 생성했을 때 그 객체는 빈이 아님!
    
    + ApplicationContext.getBean() 으로 얻어질 수 있는 객체==빈
    + 즉, ApplicationContext가 만들어서 그안에 담고있는 객체를 의미함.
  
  * **빈(Bean) 등록**
  1. Component Scanning
  2. 빈 설정파일에 직접 빈 등록

    
   프레임워크 vs 라이브러리
   
   * 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크 O (JUnit)
   * 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아닌 라이브러리 O
   
   IoC의 개념 (컨테이너)
    
   * Ioc(Inversion of Control, 제어권의 역전) 이라고 함.
   * 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것을 의미
   * 인스턴스 생성~ 소멸까지의 인스턴스 생명주기 관리를 개발자가 아닌 컨테이너가 대신 해줌
   * 즉, 직접 new를 쓰지 않도록 해준다!

   @SpringBootApplication 이란?
    
   * @SpringBootApplication 어노테이션은 auto-configuration을 담당함
   * 이 어노테이션으로 인해 스프링 부트의 자동 설정, 스프링 Bean 읽기, 생성이 모두 자동으로 설정됨! 

   **SOLID**
   클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리
   
   SRP (Single responsibility principle)
   
   
   단일 책임 원칙
   
   * 한 클래스는 하나의 책임만 가져야 함.
    * 하나의 책임이란게 좀 모호하다.
      * 클 수 있고, 작을 수 있다.
      * 문맥과 상황에 따라 다르다.
   * 중요한 기준은 **변경**. 변경이 있을 떄 파급 효과가 적으면 SRP를 잘 따른 것
   * 예) 객체의 생성과 사용을 분리
 
   OCP (Open/closed principle)
   
   개방-폐쇄 원칙
   
   * 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
   * **다형성** 활용
   * 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현

   ```
   public class MemberService
   {
    //private MemberRepository memberRepository = new MemoryMemberRepository();
      private MemberRepository memberRepository = new JdbcMemberRepository();
   ```
   LSP (Liskov substitution principle) 
   
   리스코프 치환 원칙
   
   * 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
   * 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙!
   * 예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현해버리면 LSP 위반, 느리더라도 앞으로 가면 LSP를 따른 것

   ISP (Interface segregation principle) 
   
   인터페이스 분리 원칙
   
   * 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
   * 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스 분리
   * 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트 분리
   * 인터페이스가 명확해지고, 대체 가능성 높아짐

   DIP (Dependency inversion principle) 
   
   의존관계 역전 원칙 
   
   * 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.
   * 쉽게 이야기하면 구현 클래스에 의존 X, 인터페이스 의존 O

   **스프링 컨테이너**
   
   * 'ApplicationContext'를 스프링 컨테이너라 한다. (BeanFactory 기능을 모두 상속받음!)
   * 기존에는 개발자가 클래스를 사용해서 직접 객체 생성하고 DI를 했지만, 이젠 스프링 컨테이너를 통해서 사용!!
   * 스프링 컨테이너는 '@Configuration'이 붙은 'Appconfig'를 설정(구성)정보로 사용한다. 여기서 '@Bean'이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록. 
     이렇게 스프링 컨테이너에 등록된 객체가 스프링 빈이다!
   * 스프링 빈은 '@Bean'이 붙은 메서드의 명을 스프링 빈의 이름으로 사용함!
   * 이전에는 개발자가 필요한 객체를 조회하는 클래스를 만들어서 직접 조회했지만, 이젠 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야함 
     스프링 빈은 'applicationContext.getBean()' 메서드를 사용해서 찾을 수 있음!
     
     
   ApplicationContext 부가기능
   
   * MessageSource : 예를 들어 한국에서 들어오면 한국어로 영어권에서 들어오면 영어로 출력해줌 
   * EnvironmentCapable(환경 변수) : 로컬, 개발, 운영등을 구분해서 처리함 
   * ApplicationEventPublisher : 이벤트를 발행하고 구독하는 모델을 편리하게 지원해줌 
   * ResourceLoader : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회
     
   
     
   **테스트 케이스**
   
   * 개발한 기능을 실행해서 테스트 할 때 자바의 main 메서드를 실행하거나, 웹 애플리케이션의 컨트롤러를 통해서 실행함
   * 이러한 방법은 준비, 실행하는데 오래 걸리고, 반복 실행하기 어렵다. 즉 여러 테스트를 한번에 실행하기 어려움!
   * 그래서 자바는 JUnit이라는 프레임워크로 테스트를 실행해서 이러한 문제를 해결함

   
   JUnit 이란
   
   * JUnit은 단위테스트 도구. 외부 라이브러리를 통한 테스팅 프로그램을 작성하여 System.out.println으로 번거롭게 콘솔 창에서 디버깅 작업을 하지 않아두 됨.
   * 프로그램 테스트 시 걸릴 시간 및 환경도 관리할 수 있게 해주는 오픈소스 
   * 시스템에 구현 목표의 어느 정도 개발이 진행되면 프로그램에 대한 단위 테스트는 반드시 수행 되어야 함! 


   JUnit의 특징
   
   * 단위 테스트 프레임워크 중 가장 많이 쓰이는 도구
   * 어노테이션으로 기능들을 간단하게 지원하여 쉽게 접근 가능
   * 결과는 성공(녹색), 실패(붉은색) 중 하나로 표시하여 명확한 결과를 알 수 있다.
   * assertThat, assertEquals 등의 메서드로 테스트 케이스의 수행 결과를 판별할 수 있다.

 
   싱글톤 패턴
   
   * 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴
   * 2개 이상의 객체 X
   * private(접근 지시 제어자)를 이용하여 new로 생성하지 못하게 할 수 있음
   
   싱글톤 패턴의 장단점 
   
   장점 
   
   * 여러 요청이 들어오더라도, 이미 만들어진(싱글톤) 객체를 공유해서 효율적으로 사용이 가능하다!

   단점
   
   * 싱글톤 패턴 구현 코드가 많고 길다
   * 클라이언트가 구체화에 의존함 -> DIP 위반!
   * private 생성자 -> 자식 클래스 생성 어려움 등 단점이 있다.

   이런 문제점을 해결해 주기 위해 **싱글톤 컨테이너** 이다
   
   싱글톤 컨테이너

   스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하며, 객체 인스턴스를 싱글톤(1개만 생성!)으로 관리함
   
   * 스프링 컨테이너는 싱글턴 패턴을 따로 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
   * 스프링 컨테이너 == 싱글톤 컨테이너. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 함
   * 이런 기능 덕분에 싱글톤 패턴의 단점을 해결하며 객체를 싱글톤으로 유지 가능
     * 싱글톤 패턴을 위한 지저분한 코드가 필요 X 
     * DIP, 테스트, private 생성자로부터 자유롭게 싱글톤 사용 O
   
   ![](https://media.vlpt.us/images/syleemk/post/b0c31f8b-8332-4389-af62-f7e26ccf1ce4/image.png)
     
   * 스프링의 기본 빈 등록 방식은 **싱글톤**이지만, 싱글톤 방식만 지원하는 것은 아님. 
   * 싱글톤과 달리 요청할 때 마다 새로운 객체를 생성하여 반환해주는 기능도 제공함! (빈 스코프)  

   싱클톤 방식의 주의점

   * 싱글톤 패턴이든, 스프링 같은 싱클톤 컨테이너든, 객체 인스턴스를 하나만 생성해서 공유하는 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 
     싱글톤 객체는 상태를 유지(stateful)하게 설계하면 절대 안됨!!
   
   * 무상태(stateless)로 설게 해야 댐!
     * 특정 클라이언트에 의존적인 필드가 있으면 안됨
     * 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안됨
     * 가급적 읽기만 가능해야 함 ( 가급적 값 수정 X ) 
     * 필드 대신에 자바에서 공유되지 않는 지역변수, 파라미터, ThreadLocal 등을 사용해야 함
    
   * 스프링 빈의 필드에 공유 값을 설정하게 되면 정말 큰 장애가 발생 가능!! 
   * 만약 무상태로 설계를 안하게 되면? (나의 아이디인데 남의 이름이 보임 ???)
   * 그러니 공유필드는 진짜 조심해야 함! 스프링 빈은 항상 무상태로 설계하기


   * @Configuration  
    
     * 이 어노테이션은 싱글톤을 유지해주는 기능이 있다.
     * 만약 'AppConfig' 라는 스프링 빈을 조회하여 클래스 정보를 출력했을 때 뭐시기 AppConfig가 출력되어야 함 
      그런데 예상과는 달리 클래스 명에 xxxCGLIB 라는 것이 붙게 된다. 
     * 즉, CGLIB라는 바이트코드 조작 라이브러리를 사용하여 AppConfig 클래스를 상속받은 **임의**의 다른 클래스를 만들고, 그 **임의**의 클래스를 스프링 빈으로 등록한 것!
     * 정리 
      * @Bean만 사용해도 스프링 빈으로 등록은 된다. 하지만 싱글톤은 보장하지 않는다
      * 의존관계 주입이 필요해서 메서드를 직접 호출할 때 싱글톤 보장하지 않음
     * 스프링 설정 정보는 항상 @Configuration 사용하기!


     ![스크린샷 2021-11-17 오후 4 22 30](https://user-images.githubusercontent.com/68314042/142154761-7ec697f6-c2fc-4e6d-a732-ac51406ca0ff.png)




     컴포넌트 스캔
     
     * 스프링은 설정 정보가 없어도 자동으로 스프링 빈을 등록해주는 컴포넌트 스캔이라는 기능을 제공함
     * 또 의존관계도 자동으로 주입해주는 @AutoWired 라는 기능도 제공함
     * 컴포넌트 스캔을 사용하려면 먼저 @ComponentScan 어노테이션을 붙여주면 끝!
     * 컴포넌트 스캔은 이름 그대로 @Component 어노테이션이 붙은 클래스를 스캔하여 스프링 빈으로 등록함
     * 스프링 빈으로 등록할 클래스들을 스캔 대상이 되도록 @Component를 붙여주기
     
     
     컴포넌트 스캔 탐색 위치와 기본 스캔 대상
     
     * basePackages : 탐색할 패키지의 시작 위치 지정. 지정한 패키지 포함 하위 패키지 모두 탐색 
     * basePackageClasses : 지정한 클래스의 패키지를 탐색 시작 위로 지정한다.
     * 만약 지정하지 않으면 @ComponentScan 이 붙은 설정 정보 클래스의 패키지가 시작 위치가 됨! 
     * 권장하는 방법 : 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것!( 최상단에 두게 되면 하위 패키지까지 쑥 훑어서 스캔할 것이기 때문에)
     
     기본 스캔 대상 
     컴포넌트 스캔은 @Component 뿐만 아니라 다음의 어노테이션들도 추가로 대상에 포함댐 
     
     * @Component : 컴포넌트 스캔에서 사용
     * @Controller : 스프링 MVC 컨트롤러에서 사용 ( 스프링 MVC 컨트롤러로 인식까지 해줌!)
     * @Service : 스프링 비즈니스 로직에서 사용 (딱히 특별한 처리를 해주지는 않지만, 개발자들이 핵심 비즈니스 로직을 파악하고 인식하기 쉬워짐)
     * @Repository : 스프링 데이터 접근 계층에서 사용 (스프링 데이터 접근 계층으로 인식해줌!)
     * @Configuration : 스프링 설정 정보에서 사용 (스프링 설정 정보로 인식, 스프링 빈이 싱글톤으로 유지할 수 있게 추가 처리를 해줌)

     다양한 의존관계 주입 방법
     
     의존관계 주입은 크게 4가지 방법이 있다
     * 생성자 주입
     * 수정자 주입(setter 주입)
     * 필드 주입
     * 일반 메서드 주입

     
     1.생성자 주입
     
     * 이름 그대로 생성자를 통해서 의존 관계를 주입 받는 방법
     * 특징
      * 생성자 호출시점에 딱 1번만 호출되는 것이 보장됨
      * 불변, 필수 의존관계에 사용됨

     
     2.수정자 주입 
     
     * setter 메서드로 의존관계를 주입하는 방법(수정자 메서드)
     * 특징
      * 선택, 변경 가능성이있는 의존관계에 사용
      * 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법

     자바빈 프로퍼티 규약
     
     * 자바는 과거부터 필드의 값을 직접 변경하지 않고, setXxx, getXxx 라는 메서드를 통해서 갋을 읽거나 수정하는 규칙을 만들었다. 그것이 자바빈 프로퍼티 규약

     
     3.필드 주입

     * 이름 그대로 필드에 바로 주입하는 방법
     * 특징
       - 코드가 간결하지만, 외부에서 변경이 불가능하기에 테스트 하기 힘들다는 큰 단점이 있다. 
       - DI 프레미워크가 없으면 아무것도 못한다
       - 되도록 사용 X 


     4.일반 메서드 주입

     * 일반 메서드를 통해서 주입 받는다
     * 특징
       * 한번에 여러 필드 주입 받을 수 있음
       * 일반적으로 잘 사용하지 않음


     생성자 주입을 사용하는 이유!
     
     과거에는 수정자, 필드 주입을 많이 사용했지만, 최근에는 스프링을 포함한 DI 프레임워크 대부분이 생성자 주입을 권장한다!!
     
     **불변**
     
     * 대부분의 의존관계 주입은 한번 일어나면 애플리케이션 종료시점까지 의존관계를 변경할 일이 없다. 
       오히려 대부분의 의존관계는 애플리케이션 종료 전까지 변하면 안된다( 불변 )
     
     * 수정자 주입이라면 setXxx 메서드를 public으로 해둬야 댐
     * 그러므로 누군가 실수로 변경할 수 있고, 변경하면 안되는 메서드를 열어두는 것은 좋지 않은 설계이다.
     * 그러나 생성자 주입은 객체를 생성할 때 딱 1번만 호출되기에 불변되게 설계 가능!!

     
     **정리**
     
     * 생성자 주입 방식을 선택하는 이유 중 하나는 프레임워크에 의존하지 않고, 순수한 자바 언어의 특징을 잘 살리는 방법이다!
     * 항상 생성자 주입을 선택하는게 바람직 할 것 같다! 가끔 옵션이 필요하면 수정자(setter) 주입을 선택하기, 필드 주입은 사용하지 않을 것 같다!
     * final 키워드 : 생성자 주입을 사용하게 되면 final 사용 가능! 그래서 생성자에서 혹시라도 값이 설정되지 않는 오류를 컴파일 시점에 막아준다! 
       
       
       - final 키워드 참고 : 수정자 주입을 포함한 나머지 주입 방식은 모두 생성자 이후에 호출되므로, 필드에 final 키워드 사용 불가능, 오직 생성자 주입 방식만 final 키워드 사용 가능!  
     

출처 : 인프런(https://www.inflearn.com/) 
      스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 (김영한) 강의
      스프링 핵심 원리 -기본편 (김영한) 
