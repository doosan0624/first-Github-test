스프링 개념 정리글  (스프링 핵심 원리 끝나고 다시 재정리 하기)
  * **Spring MVC란**
    + Spring 프레임워크에서 제공하는 웹 모듈
    + MVC는 Model-View-Controller의 약자이고, 기본 시스템 모듈을 MVC로 나누어 구현되어 있다.
      1. Model은 '데이터' 디자인을 담당
         + ex) 상품 목록, 주문 내역 등  
      
      2. View는 '실제로 렌더링되어 보이는 페이지'를 담당
         + ex) .JSP 파일들이 여기에 해당된다.
      
      3. Controller는 사용자의 요청을 받고, 응답을 주는 '로직'을 담당
         + ex) GET 등의 uri 매핑이 해당

      
      4. Spring MVC 모듈을 사용하여, 백엔드 프로그래밍의 기본 프레임워크를 잡는다. 
        + Web 서버에 특화되어 만들어진 모듈, 개발자가 해야할 영역을 더 **적게** 만들어준다.
        + 즉, 기존에 Spring보다 더 깔끔하고 간편하게 개발 가능.

 * **빈(Bean)** 
  1. Spring IoC 컨테이너가 관리하는 자바 객체를 빈(Bean)이라는 용어로 부른다.
  2. new 연산자로 어떤 객체를 생성했을 때 그 객체는 빈이 아님!
    
    + ApplicationContext.getBean() 으로 얻어질 수 있는 객체==빈
    + 즉, ApplicationContext가 만들어서 그안에 담고있는 객체를 의미함.
  
  * **빈(Bean) 등록**
  1. Component Scanning
  2. 빈 설정파일에 직접 빈 등록

    
   프레임워크 vs 라이브러리
   
   * 프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 그것은 프레임워크 O (JUnit)
   * 반면에 내가 작성한 코드가 직접 제어의 흐름을 담당한다면 그것은 프레임워크가 아닌 라이브러리 O
   
   IoC의 개념 (컨테이너)
    
   * Ioc(Inversion of Control, 제어권의 역전) 이라고 함.
   * 객체의 생성, 생명주기의 관리까지 모든 객체에 대한 제어권이 바뀌었다는 것을 의미
   * 인스턴스 생성~ 소멸까지의 인스턴스 생명주기 관리를 개발자가 아닌 컨테이너가 대신 해줌
   * 즉, 직접 new를 쓰지 않도록 해준다!

   @SpringBootApplication 이란?
    
   * @SpringBootApplication 어노테이션은 auto-configuration을 담당함
   * 이 어노테이션으로 인해 스프링 부트의 자동 설정, 스프링 Bean 읽기, 생성이 모두 자동으로 설정됨! 

   **SOLID**
   클린코드로 유명한 로버트 마틴이 좋은 객체 지향 설계의 5가지 원칙을 정리
   
   SRP (Single responsibility principle)
   
   
   단일 책임 원칙
   
   * 한 클래스는 하나의 책임만 가져야 함.
    * 하나의 책임이란게 좀 모호하다.
      * 클 수 있고, 작을 수 있다.
      * 문맥과 상황에 따라 다르다.
   * 중요한 기준은 **변경**. 변경이 있을 떄 파급 효과가 적으면 SRP를 잘 따른 것
   * 예) 객체의 생성과 사용을 분리
 
   OCP (Open/closed principle)
   
   개방-폐쇄 원칙
   
   * 소프트웨어 요소는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다.
   * **다형성** 활용
   * 인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능 구현

   ```
   public class MemberService
   {
    //private MemberRepository memberRepository = new MemoryMemberRepository();
      private MemberRepository memberRepository = new JdbcMemberRepository();
   ```
   LSP (Liskov substitution principle) 
   
   리스코프 치환 원칙
   
   * 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
   * 다형성에서 하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것, 다형성을 지원하기 위한 원칙!
   * 예) 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가게 구현해버리면 LSP 위반, 느리더라도 앞으로 가면 LSP를 따른 것

   ISP (Interface segregation principle) 
   
   인터페이스 분리 원칙
   
   * 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 낫다
   * 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스 분리
   * 사용자 클라이언트 -> 운전자 클라이언트, 정비사 클라이언트 분리
   * 인터페이스가 명확해지고, 대체 가능성 높아짐

   DIP (Dependency inversion principle) 
   
   의존관계 역전 원칙 
   
   * 프로그래머는 "추상화에 의존해야지, 구체화에 의존하면 안된다." 의존성 주입은 이 원칙을 따르는 방법 중 하나이다.
   * 쉽게 이야기하면 구현 클래스에 의존 X, 인터페이스 의존 O

   **스프링 컨테이너**
   
   * 'ApplicationContext'를 스프링 컨테이너라 한다. (BeanFactory 기능을 모두 상속받음!)
   * 기존에는 개발자가 클래스를 사용해서 직접 객체 생성하고 DI를 했지만, 이젠 스프링 컨테이너를 통해서 사용!!
   * 스프링 컨테이너는 '@Configuration'이 붙은 'Appconfig'를 설정(구성)정보로 사용한다. 여기서 '@Bean'이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록. 
     이렇게 스프링 컨테이너에 등록된 객체가 스프링 빈이다!
   * 스프링 빈은 '@Bean'이 붙은 메서드의 명을 스프링 빈의 이름으로 사용함!
   * 이전에는 개발자가 필요한 객체를 조회하는 클래스를 만들어서 직접 조회했지만, 이젠 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야함 
     스프링 빈은 'applicationContext.getBean()' 메서드를 사용해서 찾을 수 있음!
     
     
   ApplicationContext 부가기능
   
   * MessageSource : 예를 들어 한국에서 들어오면 한국어로 영어권에서 들어오면 영어로 출력해줌 
   * EnvironmentCapable(환경 변수) : 로컬, 개발, 운영등을 구분해서 처리함 
   * ApplicationEventPublisher : 이벤트를 발행하고 구독하는 모델을 편리하게 지원해줌 
   * ResourceLoader : 파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회
     
   
     
   **테스트 케이스**
   
   * 개발한 기능을 실행해서 테스트 할 때 자바의 main 메서드를 실행하거나, 웹 애플리케이션의 컨트롤러를 통해서 실행함
   * 이러한 방법은 준비, 실행하는데 오래 걸리고, 반복 실행하기 어렵다. 즉 여러 테스트를 한번에 실행하기 어려움!
   * 그래서 자바는 JUnit이라는 프레임워크로 테스트를 실행해서 이러한 문제를 해결함

   
   JUnit 이란
   
   * JUnit은 단위테스트 도구. 외부 라이브러리를 통한 테스팅 프로그램을 작성하여 System.out.println으로 번거롭게 콘솔 창에서 디버깅 작업을 하지 않아두 됨.
   * 프로그램 테스트 시 걸릴 시간 및 환경도 관리할 수 있게 해주는 오픈소스 
   * 시스템에 구현 목표의 어느 정도 개발이 진행되면 프로그램에 대한 단위 테스트는 반드시 수행 되어야 함! 


   JUnit의 특징
   
   * 단위 테스트 프레임워크 중 가장 많이 쓰이는 도구
   * 어노테이션으로 기능들을 간단하게 지원하여 쉽게 접근 가능
   * 결과는 성공(녹색), 실패(붉은색) 중 하나로 표시하여 명확한 결과를 알 수 있다.
   * assertThat, assertEquals 등의 메서드로 테스트 케이스의 수행 결과를 판별할 수 있다.

 
   싱글톤 패턴
   
   * 클래스의 인스턴스가 1개만 생성되는 것을 보장하는 디자인 패턴
   * 2개 이상의 객체 X
   * private(접근 지시 제어자)를 이용하여 new로 생성하지 못하게 할 수 있음
   
   싱글톤 패턴의 장단점 
   
   장점 
   
   * 여러 요청이 들어오더라도, 이미 만들어진(싱글톤) 객체를 공유해서 효율적으로 사용이 가능하다!

   단점
   
   * 싱글톤 패턴 구현 코드가 많고 길다
   * 클라이언트가 구체화에 의존함 -> DIP 위반!
   * private 생성자 -> 자식 클래스 생성 어려움 등 단점이 있다.

   이런 문제점을 해결해 주기 위해 **싱글톤 컨테이너** 이다
   
   싱글톤 컨테이너

   스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하며, 객체 인스턴스를 싱글톤(1개만 생성!)으로 관리함
   
   * 스프링 컨테이너는 싱글턴 패턴을 따로 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
   * 스프링 컨테이너 == 싱글톤 컨테이너. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 함
   * 이런 기능 덕분에 싱글톤 패턴의 단점을 해결하며 객체를 싱글톤으로 유지 가능
     * 싱글톤 패턴을 위한 지저분한 코드가 필요 X 
     * DIP, 테스트, private 생성자로부터 자유롭게 싱글톤 사용 O
   
   ![](https://media.vlpt.us/images/syleemk/post/b0c31f8b-8332-4389-af62-f7e26ccf1ce4/image.png)
     
   * 스프링의 기본 빈 등록 방식은 **싱글톤**이지만, 싱글톤 방식만 지원하는 것은 아님. 
   * 싱글톤과 달리 요청할 때 마다 새로운 객체를 생성하여 반환해주는 기능도 제공함! (빈 스코프)  






**출처 : 인프런(https://www.inflearn.com/) 
        스프링 입문 - 코드로 배우는 스프링 부트, 웹 MVC, DB 접근 기술 (김영한) 강의
        스프링 핵심 원리 -기본편 (김영한) 
